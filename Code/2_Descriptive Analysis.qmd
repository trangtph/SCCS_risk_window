---
title: "Project SCCS Risk Window Scanning"
subtitle: "Descriptive Analysis"
author: "Trang Tu - Albert Chuang"
format: 
  docx:
    documentclass: report
    margin-left: 20 mm
    margin-right: 20 mm
    margin-top: 20 mm
    margin-bottom: 20 mm
    fig-dpi: 300
    fig-align: center
    fig-width: 5
    fig-height: 3
execute: 
  echo: false
  warning: true
  message: true
  output: true
  freeze: auto
editor: visual
---

```{r}
#if (!require("pacman", quietly = TRUE)) {
#  install.packages("pacman")
#}

#library(pacman)
#pacman::p_load(
#  dplyr,
#  rio,
#  here,
#  ggplot2,
#  lubridate,
#  SCCS,
#  survival,
#  flextable
#  )

library(dplyr)
library(rio)
library(here)
library(ggplot2)
library(lubridate)
library(SCCS)
library(survival)
library(flextable)
library(scales)
```

```{r}
# Load the clean and restructured data

files <- c("individual", "myo_sccs", "pe_sccs", "thrc_sccs", "covid_infection", "comorb_stat", "covid_vacc_wide")

cdm_sccs <- setNames(
  lapply(files, function(nm) {
    rio::import(here("Processed_data", paste0(nm, ".rds")), trust = TRUE)
  }),
  files
)

cat("Check the structure of imported files:")
str(cdm_sccs, max.level = 1)
```

## Distribution of observation time

Kaplan-Meier curve for observation time:

```{r echo=FALSE}
# Create survival object and fit Kaplan-Meier
km_fits <- lapply(cdm_sccs[c("myo_sccs", "pe_sccs", "thrc_sccs")], function(dat) {
  surv_obj <- with(dat,
                   Surv(time = obs_end, event = rep(1, nrow(dat))))
  survfit(surv_obj ~ 1)
})

names(km_fits) <- c("myo", "pe", "thrc")
```

```{r}
#| label: fig-km-obs
#| fig-cap: "Percentage of individuals remaining under observation over time per outcome"

cols <- c("black", "blue", "red")

plot(
  km_fits[[1]],
  xlab = "Days since start of observation",
  ylab = "Individuals remaining \n under observation (%)",
  fun  = function(y) y * 100,
  conf.int = FALSE,
  col = cols[1],
  lwd = 2
)

for (i in 2:length(km_fits)) {
  lines(
    km_fits[[i]],
    fun = function(y) y * 100,
    conf.int = FALSE,
    col = cols[i],
    lwd = 2
  )
}

legend(
  "bottomleft",
  legend = names(km_fits),
  col = cols,
  lwd = 2,
  bty = "n"
)
```


## Distributions of exposures and outcomes

### Distribution of outcome events over the observation period:

```{r}
# Function to plot monthly counts of events: 
plot_monthly_counts <- function(df, date_var, label, ylab = "Number of events") {
  df_month <- df %>%
    filter(!is.na({{ date_var }})) %>%
    mutate(month = lubridate::floor_date({{ date_var }}, "month")) %>%
    count(month, name = "n")

  ggplot(df_month, aes(x = month, y = n)) +
    geom_col(fill = "grey70", color = "grey30") +
    scale_x_date(
      date_breaks = "3 months",
      date_labels = "%Y-%m"
    ) +
    labs(
      title = paste0(label, " (N = ", sum(df_month$n), ")"),
      x = "Month",
      y = ylab
    ) +
    theme_minimal(base_size = 12) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
}
```

<!-- Note: Please check the following figures to ensures that all events are within 01 Oct 2020 and 30 April 2022 -->
```{r}
#| label: fig-event_count
#| fig-cap: "Monthly event counts by outcome"

# Apply the function

plot_monthly_counts(cdm_sccs$myo_sccs,  
                    date_var = diagnosis_date,  
                    label = "Myocarditis events")
plot_monthly_counts(cdm_sccs$pe_sccs, 
                    date_var =  diagnosis_date, 
                    label = "PE events")
plot_monthly_counts(cdm_sccs$thrc_sccs, 
                    date_var = diagnosis_date, 
                    label = "Thrombocytopenia events")
```

### Distribution of vacc date

```{r}
#| label: fig-vacc_count
#| fig-cap: "Monthly vaccination counts by vaccine brand and dose"
plot_monthly_counts(cdm_sccs$covid_vacc_wide,  
                    date_var = bnt_1_date,  
                    label = "BNT dose 1", ylab = "Number of vaccinations")
plot_monthly_counts(cdm_sccs$covid_vacc_wide,  
                    date_var = bnt_2_date,  
                    label = "BNT dose 2", ylab = "Number of vaccinations")
plot_monthly_counts(cdm_sccs$covid_vacc_wide,  
                    date_var = chad_1_date,  
                    label = "ChAd dose 1", ylab = "Number of vaccinations")
plot_monthly_counts(cdm_sccs$covid_vacc_wide,  
                    date_var = chad_2_date,  
                    label = "ChAd dose 2",ylab = "Number of vaccinations")
```

### Dosing interval

-   `bnt_interval` and `chad_interval`: interval between vaccine dose 1 and the earliest of (dose 2, end of observation).

-   `bnt2_to_end` and `chad2_to_end`: interval between dose 2 and end of observation.

```{r}
# Calculate the interval between dose 1 and dose 2, and between dose 2 and end of observation
cdm_sccs$covid_vacc_wide <- cdm_sccs$covid_vacc_wide %>%
  left_join(cdm_sccs$individual %>% select(id, obs_end_date), by = "id")
  
cdm_sccs$covid_vacc_wide <- cdm_sccs$covid_vacc_wide %>%
  mutate(bnt_interval = ifelse(!is.na(bnt_2_date), 
                               as.numeric(pmin(bnt_2_date, obs_end_date) - bnt_1_date),
                               as.numeric(obs_end_date - bnt_1_date)),
         bnt2_to_end =  as.numeric(obs_end_date) - as.numeric(bnt_2_date),
         chad_interval = ifelse(!is.na(chad_2_date), 
                               as.numeric(pmin(chad_2_date, obs_end_date) - chad_1_date),
                               as.numeric(obs_end_date - chad_2_date)),
         chad2_to_end =  as.numeric(obs_end_date) - as.numeric(chad_2_date)
         )
```

```{r}
#| label: fig-dose-interval
#| fig-cap: "Interval in days between dose 1 and dose 2, and between dose 2 and end of observation"
#| fig-height: 5

# Summarise the intervals
vars <- c(
  "bnt_interval",
  "bnt2_to_end",
  "chad_interval",
  "chad2_to_end"
)

summary(cdm_sccs$covid_vacc_wide[
  , vars
])

# Histograms of intervals
par(mfrow = c(2, 2), mar = c(4, 4, 2, 1))

for (v in vars) {
  hist(
    cdm_sccs$covid_vacc_wide[[v]],
    breaks = 30,
    main = v,
    xlab = "Days",
    col = "grey",
    border = "white"
  )
}
```

### Distribution of 1st COVID-19 infection

```{r}
#| label: fig-inf_count
#| fig-cap: "Monthly incidence of COVID-19 infection"
plot_monthly_counts(cdm_sccs$individual,  
                    date_var = infect_date,  
                    label = "First COVID-19 infection")
```

### Number of vaccinated cases (events could occur before or after vaccination)

```{r}
cat("Myocarditis (N cases = ", nrow(cdm_sccs$myo_sccs),")")
cdm_sccs$myo_sccs %>% summarise(case_bnt1 = sum(!is.na(bnt_1)),
                                case_bnt2 = sum(!is.na(bnt_2)),
                                case_chad1 = sum(!is.na(chad_1)),
                                case_chad2 = sum(!is.na(chad_2)),
                                )

cat("PE (N cases = ", nrow(cdm_sccs$pe_sccs),")")
cdm_sccs$pe_sccs %>% summarise(case_bnt1 = sum(!is.na(bnt_1)),
                                case_bnt2 = sum(!is.na(bnt_2)),
                                case_chad1 = sum(!is.na(chad_1)),
                                case_chad2 = sum(!is.na(chad_2)),
                                )

cat("Thrombocytopenia (N cases = ", nrow(cdm_sccs$thrc_sccs),")")
cdm_sccs$thrc_sccs %>% summarise(case_bnt1 = sum(!is.na(bnt_1)),
                                case_bnt2 = sum(!is.na(bnt_2)),
                                case_chad1 = sum(!is.na(chad_1)),
                                case_chad2 = sum(!is.na(chad_2)),
                                )
```

## Check assumptions of SCCS model

### Event-dependent observation period

-   **Histogram of time from event until end of observation**

```{r}
#| label: fig-event_to_cens
#| fig-cap: "Distribution of time from event to end of follow-up"
#| fig-width: 7

# Calculate the time from event until end of observation
cdm_sccs[c("myo_sccs", "pe_sccs", "thrc_sccs")] <- lapply(cdm_sccs[c("myo_sccs", "pe_sccs", "thrc_sccs")], function(df) {
  df %>%
    mutate(event_to_ad_end = 577-diagnosis + 1,
           event_to_censor = obs_end - diagnosis +1) 
})

# Function to plot the time from event until end of observation
plot_event_to_cens <- function(df, label){
  df |>
  tidyr::pivot_longer(
    cols = c(event_to_ad_end, event_to_censor),
    names_to = "type",
    values_to = "days") |>
    ggplot(aes(x = days)) +
  geom_histogram(
    binwidth = 10,
    colour = "gray"
  ) +
  facet_wrap(~ type, scales = "free_y") +
  labs(
    x = "Days from event",
    y = "Frequency",
    title = label) +
  scale_x_continuous(limits = c(0, 600), breaks = scales::breaks_width(60)
                     ) +   
  theme_minimal()
}

# Apply the function
plot_event_to_cens(cdm_sccs$myo_sccs, label = "Myocarditis")
plot_event_to_cens(cdm_sccs$pe_sccs, label = "PE")
plot_event_to_cens(cdm_sccs$thrc_sccs, label = "Thrombocytopenia")

```

- **Test the robustness of results to event-dependent observation period:**

```{r}
# Add censoring indicator
cdm_sccs[c("myo_sccs", "pe_sccs", "thrc_sccs")] <-
  lapply(cdm_sccs[c("myo_sccs", "pe_sccs", "thrc_sccs")], function(df) {
    df %>%
      mutate(censor = dplyr::if_else(obs_end < 577, 1, 0))
  })

# Define the funciton to test for event-dependent observation period
test_event_dep_obs <- function(dat) {

  m_base <- standardsccs(
    formula = event ~ bnt_1 + chad_1 + age,
    indiv = id_num,
    astart = obs_sta,
    aend = obs_end,
    aevent = diagnosis,
    adrug = list(
      cbind(bnt_1, bnt_2),
      cbind(chad_1, chad_2)),
    aedrug = list(
      cbind(bnt_1 + 28, bnt_2 + 28),
      cbind(chad_1 + 28, chad_2 + 28)),
    washout = list(),
    sameexpopar = c(FALSE, FALSE, FALSE),
    agegrp = seq(31, 548, by = 30),
    expogrp = list(c(0, 1), c(0, 1)),
    dataformat = "multi",
    data = dat
  )

  m_dep1 <- standardsccs(
    formula = event ~ factor(censor)/bnt_1 + chad_1 + age,
    indiv = id_num,
    astart = obs_sta,
    aend = obs_end,
    aevent = diagnosis,
    adrug = list(
      cbind(bnt_1, bnt_2),
      cbind(chad_1, chad_2)),
    aedrug = list(
      cbind(bnt_1 + 28, bnt_2 + 28),
      cbind(chad_1 + 28, chad_2 + 28)),
    washout = list(),
    sameexpopar = c(FALSE, FALSE, FALSE),
    agegrp = seq(31, 548, by = 30),
    expogrp = list(c(0, 1), c(0, 1)),
    dataformat = "multi",
    data = dat
  )

  m_dep2 <- standardsccs(
    formula = event ~ bnt_1 + factor(censor)/chad_1 + age,
    indiv = id_num,
    astart = obs_sta,
    aend = obs_end,
    aevent = diagnosis,
    adrug = list(
      cbind(bnt_1, bnt_2),
      cbind(chad_1, chad_2)),
    aedrug = list(
      cbind(bnt_1 + 28, bnt_2 + 28),
      cbind(chad_1 + 28, chad_2 + 28)),
    washout = list(),
    sameexpopar = c(FALSE, FALSE, FALSE),
    agegrp = seq(31, 548, by = 30),
    expogrp = list(c(0, 1), c(0, 1)),
    dataformat = "multi",
    data = dat
  )

  list(
    models = list(
      base = m_base$coefficients[1:8,],
      dep_obs_bnt = m_dep1$coefficients[c(2:5,24:31),],
      dep_obs_chad = m_dep2$coefficients[c(1:4,24:31),]
    ),
    lrt = list(
      dep_obs_bnt = lrtsccs(m_base, m_dep1),
      dep_obs_chad = lrtsccs(m_base, m_dep2)
    )
  )
}
```

```{r}
# Apply the function
event_dep_obs_results <- lapply(cdm_sccs[c("myo_sccs", "pe_sccs", "thrc_sccs")], test_event_dep_obs)

event_dep_obs_results
```

### Event-dependent exposure

- Time interval between the start of each exposure and the event

```{r}
# Function to calculate the event-exposure interval
exposure_centered_intervals <- function(
  data,
  event_var = "diagnosis",
  exposure_vars = c("bnt_1", "bnt_2", "chad_1", "chad_2")) {

  out <- vector("list", length(exposure_vars))
  names(out) <- exposure_vars

  for (exp in exposure_vars) {

    # keep events for exposed individuals
    d_exp <- data[!is.na(data[[exp]]), ]

    if (nrow(d_exp) == 0) {
      out[[exp]] <- NULL
      next
    }

    # interval between event and exposure time
    delta <- d_exp[[event_var]] - d_exp[[exp]]

    out[[exp]] <- data.frame(
      exposure = exp,
      delta = delta
    )
  }

  do.call(rbind, out)
}

# Apply the function
myo_to_exp <- exposure_centered_intervals(cdm_sccs$myo_sccs)
pe_to_exp <- exposure_centered_intervals(cdm_sccs$pe_sccs)
thrc_to_exp <- exposure_centered_intervals(cdm_sccs$thrc_sccs)

```


```{r}
#| label: fig-event_to_exp
#| fig-cap: "Number of events in exposed cases by time since exposure, for investigating event-dependent exposure"
#| fig-height: 5
#| fig-width: 7

# Plot the interval for each exposure and each outcome
plot_event_to_exp <- function(df, label) {
ggplot(df, aes(delta)) +
  geom_histogram(binwidth = 5, boundary = 0, colour = "gray") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  facet_wrap(~ exposure, scales = "free_y") +
  labs(
    x = "Days since exposure",
    y = "Number of events",
    title = label
  ) + 
  scale_x_continuous(limits = c(-500, 450), breaks = scales::breaks_width(90)) +
  theme_minimal()
}

plot_event_to_exp(myo_to_exp, "Myocarditis")
plot_event_to_exp(pe_to_exp, "PE")
plot_event_to_exp(thrc_to_exp, "Thrombocytopenia")
```

-   Centred observation plots to help interpret the centred event plot

```{r}
#| label: fig-centred_obs
#| fig-cap: "Centred observation plots: number of exposed cases under observation by time since exposure"

# Function to calculate number of exposed cases under observation
centred_observation_plot <- function(
  data,
  exposure_vars = c("bnt_1", "bnt_2", "chad_1", "chad_2"),
  t_min = -750,
  t_max = 500,
  by = 1
) {

  t_grid <- seq(t_min, t_max, by = by)

  out <- vector("list", length(exposure_vars))
  names(out) <- exposure_vars

  for (exp in exposure_vars) {

    # keep only exposed individuals for this exposure
    d_exp <- data[!is.na(data[[exp]]), ]
    d_exp <- d_exp %>% mutate(n_event=1)

    if (nrow(d_exp) == 0) {
      out[[exp]] <- NULL
      next
    }

    # centre observation periods on exposure
    obs_start_c <- d_exp$obs_sta - d_exp[[exp]]
    obs_end_c   <- d_exp$obs_end - d_exp[[exp]]

    E_t <- numeric(length(t_grid))

    for (j in seq_along(t_grid)) {
      t <- t_grid[j]

      inside <- (t > obs_start_c) & (t <= obs_end_c)

      E_t[j] <- sum(d_exp$n_event[inside])
    }

    out[[exp]] <- data.frame(
      exposure = exp,
      t = t_grid,
      E_t = E_t)
  }

  do.call(rbind, out)
}

# Apply the function
myo_centred_obs <- centred_observation_plot(cdm_sccs$myo_sccs)
pe_centred_obs <- centred_observation_plot(cdm_sccs$pe_sccs)
thrc_centred_obs <- centred_observation_plot(cdm_sccs$thrc_sccs)

# Make plots
ggplot(myo_centred_obs, aes(t, E_t, colour = exposure)) +
  geom_line() +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    x = "Days since exposure",
    y = "Maximum possible number of events E(t)",
    title = "Myocarditis") +
  theme_minimal()

ggplot(pe_centred_obs, aes(t, E_t, colour = exposure)) +
  geom_line() +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    x = "Days since exposure",
    y = "Maximum possible number of events E(t)",
    title = "PE") +
  theme_minimal()

ggplot(thrc_centred_obs, aes(t, E_t, colour = exposure)) +
  geom_line() +
  geom_vline(xintercept = 0, linetype = "dashed") +
  labs(
    x = "Days since exposure",
    y = "Maximum possible number of events E(t)",
    title = "Thrombocytopenia") +
  theme_minimal()
```

The centred observation plot reflects design constraints: number of exposed cases that are under observation at a given time point (the hypothetical distribution of event relative to exposure if there is no event-dependent exposure).

- Count the number of events in the period before each exposure

```{r}
lapply(
  list(thrc = thrc_to_exp, pe = pe_to_exp, myo = myo_to_exp),
  function(df)
    with(df,
         table(
           exposure,
           cut(delta, seq(-120, 0, 30), right = FALSE)
         ))
)
```

## Baseline characteristics of cases (per outcome)

```{r}
#Merge baseline characteristic info into one table
cdm_sccs[c("myo_baseline", "pe_baseline", "thrc_baseline")] <-
  lapply(cdm_sccs[c("myo_sccs", "pe_sccs", "thrc_sccs")], function(df) {
  df %>%
      dplyr::select(id, event_name) %>%
      dplyr::left_join(cdm_sccs$individual %>% dplyr::select(id, age, sex), by = "id") %>%
      dplyr::left_join(cdm_sccs$comorb_stat, by = "id")  
    })

cdm_sccs$basline_all <- rbind(cdm_sccs$myo_baseline, cdm_sccs$pe_baseline, cdm_sccs$thrc_baseline)
```

```{r}
# Helper function to calculate summary statistics
cal_median_iqr <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return("NA")
  sprintf(
    "%1.0f (%1.0fâ€“%1.0f)",
    median(x),
    quantile(x, 0.25),
    quantile(x, 0.75)
  )
}

cal_n_pct <- function(x) {
  n_yes <- sum(x == 1, na.rm = TRUE)
  n_tot <- sum(!is.na(x))
  if (n_tot == 0) return("NA")
  sprintf("%d (%.1f%%)", n_yes, 100 * n_yes / n_tot)
}

cal_missing <- function(x) {
  n <- length(x)
  n_miss <- sum(is.na(x))
  sprintf("%d (%.1f%%)", n_miss, 100 * n_miss / n)
}

# Function to make baseline characteristic table

make_table1 <- function(
  data,
  group_var = NULL,
  age_var = "age",
  sex_var = "sex",
  male_value = "Male",
  condition_vars = c("lung_disease", "ckd", "diabetes", "cvd", "cancer"),
  condition_labels = NULL
) {

  if (is.null(condition_labels)) {
    condition_labels <- condition_vars
  }

  long <- data |>
    select(all_of(c(group_var, age_var, sex_var, condition_vars))) |>
    mutate(.group = if (is.null(group_var)) "Overall" else .data[[group_var]])

  # ---- Age ----
  age_tbl <- long |>
    dplyr::group_by(.group) |>
    dplyr::summarise(
      stat = cal_median_iqr(.data[[age_var]]),
      missing = cal_missing(.data[[age_var]]),
      .groups = "drop"
    ) |>
    tidyr::pivot_longer(-.group, names_to = "row_type", values_to = "value") |>
    dplyr::mutate(
      Characteristic = if_else(
        row_type == "stat",
        "Age, median (IQR)",
        "Age, missing n (%)"
      )
    )

  # ---- Sex (Male) ----
  sex_tbl <- long |>
    dplyr::group_by(.group) |>
    dplyr::summarise(
      stat = cal_n_pct(.data[[sex_var]] == male_value),
      missing = cal_missing(.data[[sex_var]]),
      .groups = "drop"
    ) |>
    tidyr::pivot_longer(-.group, names_to = "row_type", values_to = "value") |>
    dplyr::mutate(
      Characteristic = if_else(
        row_type == "stat",
        "Male, n (%)",
        "Sex, missing n (%)"
      )
    )

  # ---- Comorbidities ----
  cond_tbl <- lapply(seq_along(condition_vars), function(i) {
    v <- condition_vars[i]
    lab <- condition_labels[i]

    long |>
      dplyr::group_by(.group) |>
      dplyr::summarise(
        stat = cal_n_pct(.data[[v]]),
        missing = cal_missing(.data[[v]]),
        .groups = "drop"
      ) |>
      tidyr::pivot_longer(-.group, names_to = "row_type", values_to = "value") |>
      dplyr::mutate(
        Characteristic = if_else(
          row_type == "stat",
          paste0(lab, ", n (%)"),
          paste0(lab, ", missing n (%)")
        )
      )
  }) |>
    bind_rows()

  bind_rows(age_tbl, sex_tbl, cond_tbl) |>
    dplyr::select(Characteristic, .group, value) |>
    tidyr::pivot_wider(
      names_from = .group,
      values_from = value
    )
}

# Function to compute N per group (for headers) 
get_group_sizes <- function(data, group_var = NULL) {

  if (is.null(group_var)) {
    tibble(
      group = "Overall",
      N = nrow(data)
    )
  } else {
    data |>
      dplyr::filter(!is.na(.data[[group_var]])) |>
      dplyr::count(.data[[group_var]], name = "N") |>
      dplyr::rename(group = .data[[group_var]])}
}

# Function to add N to column headers

add_group_N_to_header <- function(ft, group_sizes) {

  header_map <- setNames(
    paste0(group_sizes$group, " (N = ", group_sizes$N, ")"),
    group_sizes$group
  )

  flextable::set_header_labels(ft, values = header_map)
}

```

```{r}
# Make the table
tbl_baseline <- make_table1(
  cdm_sccs$basline_all,
  group_var = "event_name",
  condition_vars = c("lung_disease", "ckd", "diabetes", "cvd", "cancer"),
  condition_labels = c("Lung disease", "Chronic kidney disease",
    "Diabetes","Cardiovascular disease","Cancer")
)
```

```{r eval=TRUE}
#| results: asis
# Note: If package `flextable` is not available, change eval = FALSE to this chunk,and change eval = TRUE to the chunk below this.

tbl_baseline_format <- flextable::flextable(tbl_baseline) |>
  set_caption("Baseline characteristics of cases") |>
  bold(part = "header") |>
  fontsize(size = 11) |>
  align(align = "center", part = "header") |>
  autofit() 

tbl_baseline_format <- add_group_N_to_header(tbl_baseline_format, 
                                             group_sizes = get_group_sizes(cdm_sccs$basline_all, 
                                                                           group_var = "event_name"))

tbl_baseline_format
```

```{r eval=FALSE}
tbl_baseline
```
